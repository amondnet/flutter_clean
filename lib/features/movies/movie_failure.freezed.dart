// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'movie_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MovieFailureTearOff {
  const _$MovieFailureTearOff();

  _MovieFailure call() {
    return const _MovieFailure();
  }

  ListNotAvailable listNotAvailable() {
    return const ListNotAvailable();
  }

  NonExistentMovie nonExistent() {
    return const NonExistentMovie();
  }
}

/// @nodoc
const $MovieFailure = _$MovieFailureTearOff();

/// @nodoc
mixin _$MovieFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() listNotAvailable,
    required TResult Function() nonExistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? listNotAvailable,
    TResult Function()? nonExistent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MovieFailure value) $default, {
    required TResult Function(ListNotAvailable value) listNotAvailable,
    required TResult Function(NonExistentMovie value) nonExistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MovieFailure value)? $default, {
    TResult Function(ListNotAvailable value)? listNotAvailable,
    TResult Function(NonExistentMovie value)? nonExistent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MovieFailureCopyWith<$Res> {
  factory $MovieFailureCopyWith(
          MovieFailure value, $Res Function(MovieFailure) then) =
      _$MovieFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$MovieFailureCopyWithImpl<$Res> implements $MovieFailureCopyWith<$Res> {
  _$MovieFailureCopyWithImpl(this._value, this._then);

  final MovieFailure _value;
  // ignore: unused_field
  final $Res Function(MovieFailure) _then;
}

/// @nodoc
abstract class _$MovieFailureCopyWith<$Res> {
  factory _$MovieFailureCopyWith(
          _MovieFailure value, $Res Function(_MovieFailure) then) =
      __$MovieFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$MovieFailureCopyWithImpl<$Res> extends _$MovieFailureCopyWithImpl<$Res>
    implements _$MovieFailureCopyWith<$Res> {
  __$MovieFailureCopyWithImpl(
      _MovieFailure _value, $Res Function(_MovieFailure) _then)
      : super(_value, (v) => _then(v as _MovieFailure));

  @override
  _MovieFailure get _value => super._value as _MovieFailure;
}

/// @nodoc

class _$_MovieFailure with DiagnosticableTreeMixin implements _MovieFailure {
  const _$_MovieFailure();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MovieFailure()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'MovieFailure'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _MovieFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() listNotAvailable,
    required TResult Function() nonExistent,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? listNotAvailable,
    TResult Function()? nonExistent,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MovieFailure value) $default, {
    required TResult Function(ListNotAvailable value) listNotAvailable,
    required TResult Function(NonExistentMovie value) nonExistent,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MovieFailure value)? $default, {
    TResult Function(ListNotAvailable value)? listNotAvailable,
    TResult Function(NonExistentMovie value)? nonExistent,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _MovieFailure implements MovieFailure {
  const factory _MovieFailure() = _$_MovieFailure;
}

/// @nodoc
abstract class $ListNotAvailableCopyWith<$Res> {
  factory $ListNotAvailableCopyWith(
          ListNotAvailable value, $Res Function(ListNotAvailable) then) =
      _$ListNotAvailableCopyWithImpl<$Res>;
}

/// @nodoc
class _$ListNotAvailableCopyWithImpl<$Res>
    extends _$MovieFailureCopyWithImpl<$Res>
    implements $ListNotAvailableCopyWith<$Res> {
  _$ListNotAvailableCopyWithImpl(
      ListNotAvailable _value, $Res Function(ListNotAvailable) _then)
      : super(_value, (v) => _then(v as ListNotAvailable));

  @override
  ListNotAvailable get _value => super._value as ListNotAvailable;
}

/// @nodoc

@Implements(FeatureFailure)
class _$ListNotAvailable
    with DiagnosticableTreeMixin
    implements ListNotAvailable {
  const _$ListNotAvailable();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MovieFailure.listNotAvailable()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MovieFailure.listNotAvailable'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ListNotAvailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() listNotAvailable,
    required TResult Function() nonExistent,
  }) {
    return listNotAvailable();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? listNotAvailable,
    TResult Function()? nonExistent,
    required TResult orElse(),
  }) {
    if (listNotAvailable != null) {
      return listNotAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MovieFailure value) $default, {
    required TResult Function(ListNotAvailable value) listNotAvailable,
    required TResult Function(NonExistentMovie value) nonExistent,
  }) {
    return listNotAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MovieFailure value)? $default, {
    TResult Function(ListNotAvailable value)? listNotAvailable,
    TResult Function(NonExistentMovie value)? nonExistent,
    required TResult orElse(),
  }) {
    if (listNotAvailable != null) {
      return listNotAvailable(this);
    }
    return orElse();
  }
}

abstract class ListNotAvailable implements MovieFailure, FeatureFailure {
  const factory ListNotAvailable() = _$ListNotAvailable;
}

/// @nodoc
abstract class $NonExistentMovieCopyWith<$Res> {
  factory $NonExistentMovieCopyWith(
          NonExistentMovie value, $Res Function(NonExistentMovie) then) =
      _$NonExistentMovieCopyWithImpl<$Res>;
}

/// @nodoc
class _$NonExistentMovieCopyWithImpl<$Res>
    extends _$MovieFailureCopyWithImpl<$Res>
    implements $NonExistentMovieCopyWith<$Res> {
  _$NonExistentMovieCopyWithImpl(
      NonExistentMovie _value, $Res Function(NonExistentMovie) _then)
      : super(_value, (v) => _then(v as NonExistentMovie));

  @override
  NonExistentMovie get _value => super._value as NonExistentMovie;
}

/// @nodoc

@Implements(FeatureFailure)
class _$NonExistentMovie
    with DiagnosticableTreeMixin
    implements NonExistentMovie {
  const _$NonExistentMovie();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MovieFailure.nonExistent()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'MovieFailure.nonExistent'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NonExistentMovie);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() listNotAvailable,
    required TResult Function() nonExistent,
  }) {
    return nonExistent();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? listNotAvailable,
    TResult Function()? nonExistent,
    required TResult orElse(),
  }) {
    if (nonExistent != null) {
      return nonExistent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MovieFailure value) $default, {
    required TResult Function(ListNotAvailable value) listNotAvailable,
    required TResult Function(NonExistentMovie value) nonExistent,
  }) {
    return nonExistent(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MovieFailure value)? $default, {
    TResult Function(ListNotAvailable value)? listNotAvailable,
    TResult Function(NonExistentMovie value)? nonExistent,
    required TResult orElse(),
  }) {
    if (nonExistent != null) {
      return nonExistent(this);
    }
    return orElse();
  }
}

abstract class NonExistentMovie implements MovieFailure, FeatureFailure {
  const factory NonExistentMovie() = _$NonExistentMovie;
}
